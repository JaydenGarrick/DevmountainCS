# DevMountain CS 

## What's the point?

Computer Science is the basis for everything you've learned at DevMountain. There are two main purposes to this additional series of classes. The first purpose is to make sure you are the most prepared and able job candidates that you can be. Knowing these principles will help you perform betting in challenging interviews and will help you be more confident in all potential job oportunities. If you don't get a job, then it will be much harder to put into practice everything that you've learned here at DevMountain. The second purpose of this course is to make sure when you do get your dream job that you will be as well prepared as possible to make well designed and efficient code. The better you understand these concepts the more clearly you will be able to think about your program in general and over time writing well designed code will become natural and instinctive. By well designed code we mean that the code is easily reusable, testable and maintainable.


# Learning Objectives

### Week 1 - Big O Notation

* __Monday__ - Define what Big O is, Recognize O(n), O(1), O(n²)
* __Tuesday__ - Define O(log n), O(2^n). Describe real life examples of O(n), O(1), O(n²)
* __Wednesday__ - Apply Big O to previous stretch problems. Describe real like examples of O(log n), O(2^n)
* __Thursday__ - Distinguish which Big O's are the fastest / most efficient. Distinguish between time and space complexity

### Week 2 - Data Structures Part 1

* __Monday__ - Describe why data structures are useful in improving Big O. Distinguish between Array and Linked-List
* __Tuesday__ - Create a Queue and a Stack using an Array or Linked-List. Be able to analyze Big O of each
* __Wednesday__ - Compare and contrast Arrays vs Dictionaries. Describe 2 things you can do to avoid collisions
* __Thursday__ -  Define what a Tree is, difference types of Trees. Be able to recognize different typs of trees

### Week 3 - Data Structures Part 2

* __Monday__ - Operate on a Binary Search Tree. Explain why a balance Binary Search Tree is desirable. Be able to analyze the Big O of a Binary Search Tree
* __Tuesday__ -  Define and explain when a heap is used and when a trie is used
* __Wednesday__ -  Describe what a Set is, and be able to operate on a Set
* __Thursday__ - Define a Graph. Recognize a problem where Graphs may be needed

### Week 4 - Interview Questions

* __Monday__ - Be able to list the steps for solving a technical question
* __Tuesday__ - Explain what B.U.D. Optimization is, solve a technical question using the B.U.D. technique
* __Wednesday__ - Explain what the D.I.Y. technique is, solve a technical question using the D.I.Y. technique. Do the same for Simplify and Generalize
* __Thursday__ -  Explain what the Base Case and Build technique is, solve a technical question using the Base Case and Build technique. Do the same with DataStructure Brainstorm

### Week 5 - Design Patterns Part 1

* __Monday__ - Describe what problem Strategy Pattern solves, and how exactly it solves that problem 
* __Tuesday__ - Describe what problem Oberserver/Decorator pattern solves, and how exactly it solves that problem 
* __Wednesday__ - Describe what problem Factory Method solves, and how exactly it solves that problem 
* __Thursday__ - Describe what problem Abstract Factory Method solves, and how exactly it solves that problem. Be able to describe the difference between Factory Method and Abstract Factory Method

### Week 6 - Design Patterns Part 2 + Review

* __Monday__ -  Describe what problem Facade solves, and how exactly it solves that problem
* __Tuesday__ - Describe what problem Proxy solves, and how exactly it solves that problem. Be able to describe the difference between Proxy and Facade Methods
* __Wednesday__ - Describe the four steps of Object Oriented Design. be able to design a Deck of Cards data structure 
* __Thursday__ - Be ready to teach any given topic we've gone over 
